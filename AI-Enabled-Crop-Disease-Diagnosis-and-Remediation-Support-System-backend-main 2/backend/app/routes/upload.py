import os
import uuid

from fastapi import APIRouter, UploadFile, File, Form, Depends
from sqlalchemy.orm import Session

from app.database import SessionLocal
from app.models.media import Media
from app.tasks.ml_task import process_ml

router = APIRouter(prefix="/api", tags=["Media"])

UPLOAD_FOLDER = "uploads"
os.makedirs(UPLOAD_FOLDER, exist_ok=True)


# ✅ DB Dependency
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


# ✅ Upload API
# This endpoint supports Offline-First Architecture.
# It accepts an optional 'media_id' generated by the client (Flutter App) while offline.
# This ensures that when the device comes online and syncs, we can de-duplicate uploads
# if the network flakes out and retries happen.
@router.post("/upload-media")
def upload_media(
    file: UploadFile = File(...),
    media_id: str = Form(None),  # Optional client-generated ID from offline mode
    user_id: str = Form(None),   # Optional user ID from client
    db: Session = Depends(get_db)
):
    # If client provides an ID (Offline Sync), use it. Otherwise, generate one (Online Direct).
    if media_id:
        # Check for existing media with this ID (Deduplication Logic)
        # This prevents processing the same image twice if the client retries the upload.
        existing_media = db.query(Media).filter(Media.media_id == media_id).first()
        if existing_media:
            return {
                "media_id": media_id,
                "status": existing_media.status,
                "message": "Media already exists (deduplicated)."
            }
    else:
        # Standard online upload flow
        media_id = str(uuid.uuid4())

    file_extension = file.filename.split(".")[-1]
    filename = f"{media_id}.{file_extension}"

    file_path = os.path.join(UPLOAD_FOLDER, filename)

    # save file locally
    with open(file_path, "wb") as buffer:
        buffer.write(file.file.read())

    # save metadata
    media = Media(
        media_id=media_id,
        media_type=file.content_type,
        status="UPLOADED",
        file_path=filename,  # Store just the filename, we know it's in uploads/
        user_id=user_id      # Store the user ID
    )

    db.add(media)
    db.commit()

    # ⭐ Trigger ML asynchronously
    # ⭐ Trigger ML synchronously
    try:
        process_ml(media_id, file_path)
    except Exception as e:
        print(f"Error processing ML: {e}")

    return {
        "media_id": media_id,
        "status": "UPLOADED",
        "message": "File uploaded. ML processing started."
    }
